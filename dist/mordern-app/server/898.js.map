{"version":3,"sources":["./node_modules/ngx-currency/fesm2015/ngx-currency.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAoJ;AACpF;AACjB;;AAEP;AACxC;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD,+BAA+B,yDAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oFAAoF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAgD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,6DAAiB;AAC9B,iBAAiB,yDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,yCAAyC,+DAAwB,2BAA2B,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,0DAAsB,GAAG;AACnQ,2CAA2C,+DAAwB,EAAE,yIAAyI;AAC9M,QAAQ,wDAAiB,yEAAyE,+BAA+B,EAAE,wEAAwE,8BAA8B,EAAE,4EAA4E,gCAAgC,EAAE,gFAAgF,kCAAkC,EAAE,kFAAkF,mCAAmC,EAAE,4EAA4E,gCAAgC,EAAE,0EAA0E,+BAA+B,EAAE;AAC7xB,KAAK,EAAE,WAAW,qBAAqB,aAAa,gEAAyB,2CAA2C;AACxH;AACA,KAAK,gCAAgC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,iCAAiC,GAAG;AAC1G,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,OAAO,0DAAe;AAC3B;AACA;AACA,KAAK,gCAAgC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,iCAAiC,GAAG;AAC1G,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,OAAO,0DAAe;AAC3B;AACA;AACA,eAAe,OAAO,gDAAK,EAAE;AAC7B,kBAAkB,OAAO,uDAAY,+BAA+B;AACpE,iBAAiB,OAAO,uDAAY,8BAA8B;AAClE,mBAAmB,OAAO,uDAAY,gCAAgC;AACtE,qBAAqB,OAAO,uDAAY,kCAAkC;AAC1E,sBAAsB,OAAO,uDAAY,mCAAmC;AAC5E,mBAAmB,OAAO,uDAAY,gCAAgC;AACtE,kBAAkB,OAAO,uDAAY,+BAA+B;AACpE;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU;AAC/B,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,GAAG,OAAO,qDAAiB,EAAE,GAAG,OAAO,0DAAsB,EAAE,EAAE,EAAE,GAAG;AACtF,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,uDAAY;AAC9B;AACA,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gEAAgE,uCAAuC;AACvG,uCAAuC,8DAAuB,EAAE,0BAA0B;AAC1F,uCAAuC,8DAAuB,EAAE,YAAY,yDAAY,EAAE,uDAAW,IAAI;AACzG,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,mDAAQ;AACtB;AACA,0BAA0B,yDAAY,EAAE,uDAAW;AACnD;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;AACtB,cAAc,oDAAoD,gEAAyB,qBAAqB,4BAA4B,gCAAgC,EAAE,wBAAwB,SAAS,yDAAY,EAAE,uDAAW,EAAE,EAAE,wBAAwB,gCAAgC,EAAE,EAAE,EAAE,EAAE;;AAE5S;AACA;AACA;;AAE6I;;AAE7I,wC","file":"898.js","sourcesContent":["import { InjectionToken, forwardRef, Optional, Inject, ElementRef, KeyValueDiffers, Directive, Input, HostListener, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\nimport * as Éµngcc0 from '@angular/core';\nvar CurrencyMaskInputMode;\n(function (CurrencyMaskInputMode) {\n    CurrencyMaskInputMode[CurrencyMaskInputMode[\"FINANCIAL\"] = 0] = \"FINANCIAL\";\n    CurrencyMaskInputMode[CurrencyMaskInputMode[\"NATURAL\"] = 1] = \"NATURAL\";\n})(CurrencyMaskInputMode || (CurrencyMaskInputMode = {}));\nlet CURRENCY_MASK_CONFIG = new InjectionToken(\"currency.mask.config\");\n\nclass InputManager {\n    constructor(htmlInputElement) {\n        this.htmlInputElement = htmlInputElement;\n    }\n    setCursorAt(position) {\n        if (this.htmlInputElement.setSelectionRange) {\n            this.htmlInputElement.focus();\n            this.htmlInputElement.setSelectionRange(position, position);\n        }\n        else if (this.htmlInputElement.createTextRange) {\n            let textRange = this.htmlInputElement.createTextRange();\n            textRange.collapse(true);\n            textRange.moveEnd(\"character\", position);\n            textRange.moveStart(\"character\", position);\n            textRange.select();\n        }\n    }\n    updateValueAndCursor(newRawValue, oldLength, selectionStart) {\n        this.rawValue = newRawValue;\n        let newLength = newRawValue.length;\n        selectionStart = selectionStart - (oldLength - newLength);\n        this.setCursorAt(selectionStart);\n    }\n    get canInputMoreNumbers() {\n        let onlyNumbers = this.rawValue.replace(/[^0-9\\u0660-\\u0669\\u06F0-\\u06F9]/g, \"\");\n        let haventReachedMaxLength = !(onlyNumbers.length >= this.htmlInputElement.maxLength && this.htmlInputElement.maxLength >= 0);\n        let selectionStart = this.inputSelection.selectionStart;\n        let selectionEnd = this.inputSelection.selectionEnd;\n        let haveNumberSelected = !!(selectionStart != selectionEnd &&\n            this.htmlInputElement.value.substring(selectionStart, selectionEnd).match(/[^0-9\\u0660-\\u0669\\u06F0-\\u06F9]/));\n        let startWithZero = (this.htmlInputElement.value.substring(0, 1) == \"0\");\n        return haventReachedMaxLength || haveNumberSelected || startWithZero;\n    }\n    get inputSelection() {\n        let selectionStart = 0;\n        let selectionEnd = 0;\n        if (typeof this.htmlInputElement.selectionStart == \"number\" && typeof this.htmlInputElement.selectionEnd == \"number\") {\n            selectionStart = this.htmlInputElement.selectionStart;\n            selectionEnd = this.htmlInputElement.selectionEnd;\n        }\n        else {\n            let range = document.selection.createRange();\n            if (range && range.parentElement() == this.htmlInputElement) {\n                let lenght = this.htmlInputElement.value.length;\n                let normalizedValue = this.htmlInputElement.value.replace(/\\r\\n/g, \"\\n\");\n                let startRange = this.htmlInputElement.createTextRange();\n                startRange.moveToBookmark(range.getBookmark());\n                let endRange = this.htmlInputElement.createTextRange();\n                endRange.collapse(false);\n                if (startRange.compareEndPoints(\"StartToEnd\", endRange) > -1) {\n                    selectionStart = selectionEnd = lenght;\n                }\n                else {\n                    selectionStart = -startRange.moveStart(\"character\", -lenght);\n                    selectionStart += normalizedValue.slice(0, selectionStart).split(\"\\n\").length - 1;\n                    if (startRange.compareEndPoints(\"EndToEnd\", endRange) > -1) {\n                        selectionEnd = lenght;\n                    }\n                    else {\n                        selectionEnd = -startRange.moveEnd(\"character\", -lenght);\n                        selectionEnd += normalizedValue.slice(0, selectionEnd).split(\"\\n\").length - 1;\n                    }\n                }\n            }\n        }\n        return {\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd\n        };\n    }\n    get rawValue() {\n        return this.htmlInputElement && this.htmlInputElement.value;\n    }\n    set rawValue(value) {\n        this._storedRawValue = value;\n        if (this.htmlInputElement) {\n            this.htmlInputElement.value = value;\n        }\n    }\n    get storedRawValue() {\n        return this._storedRawValue || '';\n    }\n}\n\nclass InputService {\n    constructor(htmlInputElement, options) {\n        this.htmlInputElement = htmlInputElement;\n        this.options = options;\n        this.SINGLE_DIGIT_REGEX = new RegExp(/^[0-9\\u0660-\\u0669\\u06F0-\\u06F9]$/);\n        this.ONLY_NUMBERS_REGEX = new RegExp(/[^0-9\\u0660-\\u0669\\u06F0-\\u06F9]/g);\n        this.PER_AR_NUMBER = new Map();\n        this.inputManager = new InputManager(htmlInputElement);\n        this.initialize();\n    }\n    initialize() {\n        this.PER_AR_NUMBER.set(\"\\u06F0\", \"0\");\n        this.PER_AR_NUMBER.set(\"\\u06F1\", \"1\");\n        this.PER_AR_NUMBER.set(\"\\u06F2\", \"2\");\n        this.PER_AR_NUMBER.set(\"\\u06F3\", \"3\");\n        this.PER_AR_NUMBER.set(\"\\u06F4\", \"4\");\n        this.PER_AR_NUMBER.set(\"\\u06F5\", \"5\");\n        this.PER_AR_NUMBER.set(\"\\u06F6\", \"6\");\n        this.PER_AR_NUMBER.set(\"\\u06F7\", \"7\");\n        this.PER_AR_NUMBER.set(\"\\u06F8\", \"8\");\n        this.PER_AR_NUMBER.set(\"\\u06F9\", \"9\");\n        this.PER_AR_NUMBER.set(\"\\u0660\", \"0\");\n        this.PER_AR_NUMBER.set(\"\\u0661\", \"1\");\n        this.PER_AR_NUMBER.set(\"\\u0662\", \"2\");\n        this.PER_AR_NUMBER.set(\"\\u0663\", \"3\");\n        this.PER_AR_NUMBER.set(\"\\u0664\", \"4\");\n        this.PER_AR_NUMBER.set(\"\\u0665\", \"5\");\n        this.PER_AR_NUMBER.set(\"\\u0666\", \"6\");\n        this.PER_AR_NUMBER.set(\"\\u0667\", \"7\");\n        this.PER_AR_NUMBER.set(\"\\u0668\", \"8\");\n        this.PER_AR_NUMBER.set(\"\\u0669\", \"9\");\n    }\n    addNumber(keyCode) {\n        const { decimal, precision, inputMode } = this.options;\n        let keyChar = String.fromCharCode(keyCode);\n        const isDecimalChar = keyChar === this.options.decimal;\n        if (!this.rawValue) {\n            this.rawValue = this.applyMask(false, keyChar);\n            let selectionStart = undefined;\n            if (inputMode === CurrencyMaskInputMode.NATURAL && precision > 0) {\n                selectionStart = this.rawValue.indexOf(decimal);\n                if (isDecimalChar) {\n                    selectionStart++;\n                }\n            }\n            this.updateFieldValue(selectionStart);\n        }\n        else {\n            let selectionStart = this.inputSelection.selectionStart;\n            let selectionEnd = this.inputSelection.selectionEnd;\n            const rawValueStart = this.rawValue.substring(0, selectionStart);\n            let rawValueEnd = this.rawValue.substring(selectionEnd, this.rawValue.length);\n            // In natural mode, replace decimals instead of shifting them.\n            const inDecimalPortion = rawValueStart.indexOf(decimal) !== -1;\n            if (inputMode === CurrencyMaskInputMode.NATURAL && inDecimalPortion && selectionStart === selectionEnd) {\n                rawValueEnd = rawValueEnd.substring(1);\n            }\n            const newValue = rawValueStart + keyChar + rawValueEnd;\n            let nextSelectionStart = selectionStart + 1;\n            const isDecimalOrThousands = isDecimalChar || keyChar === this.options.thousands;\n            if (isDecimalOrThousands && keyChar === rawValueEnd[0]) {\n                // If the cursor is just before the decimal or thousands separator and the user types the\n                // decimal or thousands separator, move the cursor past it.\n                nextSelectionStart++;\n            }\n            else if (!this.SINGLE_DIGIT_REGEX.test(keyChar)) {\n                // Ignore other non-numbers.\n                return;\n            }\n            this.rawValue = newValue;\n            this.updateFieldValue(nextSelectionStart);\n        }\n    }\n    applyMask(isNumber, rawValue, disablePadAndTrim = false) {\n        let { allowNegative, decimal, precision, prefix, suffix, thousands, min, max, inputMode } = this.options;\n        rawValue = isNumber ? new Number(rawValue).toFixed(precision) : rawValue;\n        let onlyNumbers = rawValue.replace(this.ONLY_NUMBERS_REGEX, \"\");\n        if (!onlyNumbers && rawValue !== decimal) {\n            return \"\";\n        }\n        if (inputMode === CurrencyMaskInputMode.NATURAL && !isNumber && !disablePadAndTrim) {\n            rawValue = this.padOrTrimPrecision(rawValue);\n            onlyNumbers = rawValue.replace(this.ONLY_NUMBERS_REGEX, \"\");\n        }\n        let integerPart = onlyNumbers.slice(0, onlyNumbers.length - precision)\n            .replace(/^\\u0660*/g, \"\")\n            .replace(/^\\u06F0*/g, \"\")\n            .replace(/^0*/g, \"\");\n        if (integerPart == \"\") {\n            integerPart = \"0\";\n        }\n        let integerValue = parseInt(integerPart);\n        integerPart = integerPart.replace(/\\B(?=([0-9\\u0660-\\u0669\\u06F0-\\u06F9]{3})+(?![0-9\\u0660-\\u0669\\u06F0-\\u06F9]))/g, thousands);\n        if (thousands && integerPart.startsWith(thousands)) {\n            integerPart = integerPart.substring(1);\n        }\n        let newRawValue = integerPart;\n        let decimalPart = onlyNumbers.slice(onlyNumbers.length - precision);\n        let decimalValue = parseInt(decimalPart) || 0;\n        let isNegative = rawValue.indexOf(\"-\") > -1;\n        // Ensure max is at least as large as min.\n        max = (this.isNullOrUndefined(max) || this.isNullOrUndefined(min)) ? max : Math.max(max, min);\n        // Restrict to the min and max values.\n        let newValue = integerValue + (decimalValue / 100);\n        newValue = isNegative ? -newValue : newValue;\n        if (!this.isNullOrUndefined(max) && newValue > max) {\n            return this.applyMask(true, max + '');\n        }\n        else if (!this.isNullOrUndefined(min) && newValue < min) {\n            return this.applyMask(true, min + '');\n        }\n        if (precision > 0) {\n            if (newRawValue == \"0\" && decimalPart.length < precision) {\n                newRawValue += decimal + \"0\".repeat(precision - 1) + decimalPart;\n            }\n            else {\n                newRawValue += decimal + decimalPart;\n            }\n        }\n        let isZero = newValue == 0;\n        let operator = (isNegative && allowNegative && !isZero) ? \"-\" : \"\";\n        return operator + prefix + newRawValue + suffix;\n    }\n    padOrTrimPrecision(rawValue) {\n        let { decimal, precision } = this.options;\n        let decimalIndex = rawValue.lastIndexOf(decimal);\n        if (decimalIndex === -1) {\n            decimalIndex = rawValue.length;\n            rawValue += decimal;\n        }\n        let decimalPortion = rawValue.substring(decimalIndex).replace(this.ONLY_NUMBERS_REGEX, \"\");\n        const actualPrecision = decimalPortion.length;\n        if (actualPrecision < precision) {\n            for (let i = actualPrecision; i < precision; i++) {\n                decimalPortion += '0';\n            }\n        }\n        else if (actualPrecision > precision) {\n            decimalPortion = decimalPortion.substring(0, decimalPortion.length + precision - actualPrecision);\n        }\n        return rawValue.substring(0, decimalIndex) + decimal + decimalPortion;\n    }\n    clearMask(rawValue) {\n        if (this.isNullable() && rawValue === \"\")\n            return null;\n        let value = (rawValue || \"0\").replace(this.options.prefix, \"\").replace(this.options.suffix, \"\");\n        if (this.options.thousands) {\n            value = value.replace(new RegExp(\"\\\\\" + this.options.thousands, \"g\"), \"\");\n        }\n        if (this.options.decimal) {\n            value = value.replace(this.options.decimal, \".\");\n        }\n        this.PER_AR_NUMBER.forEach((val, key) => {\n            const re = new RegExp(key, \"g\");\n            value = value.replace(re, val);\n        });\n        return parseFloat(value);\n    }\n    changeToNegative() {\n        if (this.options.allowNegative && this.rawValue != \"\" && this.rawValue.charAt(0) != \"-\" && this.value != 0) {\n            // Apply the mask to ensure the min and max values are enforced.\n            this.rawValue = this.applyMask(false, \"-\" + this.rawValue);\n        }\n    }\n    changeToPositive() {\n        // Apply the mask to ensure the min and max values are enforced.\n        this.rawValue = this.applyMask(false, this.rawValue.replace(\"-\", \"\"));\n    }\n    removeNumber(keyCode) {\n        let { decimal, thousands, prefix, suffix, inputMode } = this.options;\n        if (this.isNullable() && this.value == 0) {\n            this.rawValue = null;\n            return;\n        }\n        let selectionEnd = this.inputSelection.selectionEnd;\n        let selectionStart = this.inputSelection.selectionStart;\n        const suffixStart = this.rawValue.length - suffix.length;\n        selectionEnd = Math.min(suffixStart, Math.max(selectionEnd, prefix.length));\n        selectionStart = Math.min(suffixStart, Math.max(selectionStart, prefix.length));\n        // Check if selection was entirely in the prefix or suffix. \n        if (selectionStart === selectionEnd &&\n            this.inputSelection.selectionStart !== this.inputSelection.selectionEnd) {\n            this.updateFieldValue(selectionStart);\n            return;\n        }\n        let decimalIndex = this.rawValue.indexOf(decimal);\n        if (decimalIndex === -1) {\n            decimalIndex = this.rawValue.length;\n        }\n        let shiftSelection = 0;\n        let insertChars = '';\n        const isCursorInDecimals = decimalIndex < selectionEnd;\n        const isCursorImmediatelyAfterDecimalPoint = decimalIndex + 1 === selectionEnd;\n        if (selectionEnd === selectionStart) {\n            if (keyCode == 8) {\n                if (selectionStart <= prefix.length) {\n                    return;\n                }\n                selectionStart--;\n                // If previous char isn't a number, go back one more.\n                if (!this.rawValue.substr(selectionStart, 1).match(/\\d/)) {\n                    selectionStart--;\n                }\n                // In natural mode, jump backwards when in decimal portion of number.\n                if (inputMode === CurrencyMaskInputMode.NATURAL && isCursorInDecimals) {\n                    shiftSelection = -1;\n                    // when removing a single whole number, replace it with 0\n                    if (isCursorImmediatelyAfterDecimalPoint && this.value < 10 && this.value > -10) {\n                        insertChars += '0';\n                    }\n                }\n            }\n            else if (keyCode == 46 || keyCode == 63272) {\n                if (selectionStart === suffixStart) {\n                    return;\n                }\n                selectionEnd++;\n                // If next char isn't a number, go one more.\n                if (!this.rawValue.substr(selectionStart, 1).match(/\\d/)) {\n                    selectionStart++;\n                    selectionEnd++;\n                }\n            }\n        }\n        // In natural mode, replace decimals with 0s.\n        if (inputMode === CurrencyMaskInputMode.NATURAL && selectionStart > decimalIndex) {\n            const replacedDecimalCount = selectionEnd - selectionStart;\n            for (let i = 0; i < replacedDecimalCount; i++) {\n                insertChars += '0';\n            }\n        }\n        let selectionFromEnd = this.rawValue.length - selectionEnd;\n        this.rawValue = this.rawValue.substring(0, selectionStart) + insertChars + this.rawValue.substring(selectionEnd);\n        // Remove leading thousand separator from raw value.\n        const startChar = this.rawValue.substr(prefix.length, 1);\n        if (startChar === thousands) {\n            this.rawValue = this.rawValue.substring(0, prefix.length) + this.rawValue.substring(prefix.length + 1);\n            selectionFromEnd = Math.min(selectionFromEnd, this.rawValue.length - prefix.length);\n        }\n        this.updateFieldValue(this.rawValue.length - selectionFromEnd + shiftSelection, true);\n    }\n    updateFieldValue(selectionStart, disablePadAndTrim = false) {\n        let newRawValue = this.applyMask(false, this.rawValue || \"\", disablePadAndTrim);\n        selectionStart = selectionStart == undefined ? this.rawValue.length : selectionStart;\n        selectionStart = Math.max(this.options.prefix.length, Math.min(selectionStart, this.rawValue.length - this.options.suffix.length));\n        this.inputManager.updateValueAndCursor(newRawValue, this.rawValue.length, selectionStart);\n    }\n    updateOptions(options) {\n        let value = this.value;\n        this.options = options;\n        this.value = value;\n    }\n    prefixLength() {\n        return this.options.prefix.length;\n    }\n    suffixLength() {\n        return this.options.suffix.length;\n    }\n    isNullable() {\n        return this.options.nullable;\n    }\n    get canInputMoreNumbers() {\n        return this.inputManager.canInputMoreNumbers;\n    }\n    get inputSelection() {\n        return this.inputManager.inputSelection;\n    }\n    get rawValue() {\n        return this.inputManager.rawValue;\n    }\n    set rawValue(value) {\n        this.inputManager.rawValue = value;\n    }\n    get storedRawValue() {\n        return this.inputManager.storedRawValue;\n    }\n    get value() {\n        return this.clearMask(this.rawValue);\n    }\n    set value(value) {\n        this.rawValue = this.applyMask(true, \"\" + value);\n    }\n    isNullOrUndefined(value) {\n        return value === null || value === undefined;\n    }\n}\n\nclass InputHandler {\n    constructor(htmlInputElement, options) {\n        this.inputService = new InputService(htmlInputElement, options);\n    }\n    handleCut(event) {\n        setTimeout(() => {\n            this.inputService.updateFieldValue();\n            this.setValue(this.inputService.value);\n            this.onModelChange(this.inputService.value);\n        }, 0);\n    }\n    handleInput(event) {\n        let selectionStart = this.inputService.inputSelection.selectionStart;\n        let keyCode = this.inputService.rawValue.charCodeAt(selectionStart - 1);\n        let rawValueLength = this.inputService.rawValue.length;\n        let storedRawValueLength = this.inputService.storedRawValue.length;\n        if (Math.abs(rawValueLength - storedRawValueLength) != 1) {\n            this.inputService.updateFieldValue(selectionStart);\n            this.onModelChange(this.inputService.value);\n            return;\n        }\n        // Restore the old value.\n        this.inputService.rawValue = this.inputService.storedRawValue;\n        if (rawValueLength < storedRawValueLength) {\n            // Chrome Android seems to move the cursor in response to a backspace AFTER processing the\n            // input event, so we need to wrap this in a timeout.\n            this.timer(() => {\n                // Move the cursor to just after the deleted value.\n                this.inputService.updateFieldValue(selectionStart + 1);\n                // Then backspace it.\n                this.inputService.removeNumber(8);\n                this.onModelChange(this.inputService.value);\n            }, 0);\n        }\n        if (rawValueLength > storedRawValueLength) {\n            // Move the cursor to just before the new value.\n            this.inputService.updateFieldValue(selectionStart - 1);\n            // Process the character like a keypress.\n            this.handleKeypressImpl(keyCode);\n        }\n    }\n    handleKeydown(event) {\n        let keyCode = event.which || event.charCode || event.keyCode;\n        if (keyCode == 8 || keyCode == 46 || keyCode == 63272) {\n            event.preventDefault();\n            if (this.inputService.inputSelection.selectionStart <= this.inputService.prefixLength() &&\n                this.inputService.inputSelection.selectionEnd >= this.inputService.rawValue.length - this.inputService.suffixLength()) {\n                this.clearValue();\n            }\n            else {\n                this.inputService.removeNumber(keyCode);\n                this.onModelChange(this.inputService.value);\n            }\n        }\n    }\n    clearValue() {\n        this.setValue(this.inputService.isNullable() ? null : 0);\n        this.onModelChange(this.inputService.value);\n    }\n    handleKeypress(event) {\n        let keyCode = event.which || event.charCode || event.keyCode;\n        event.preventDefault();\n        if (keyCode === 97 && event.ctrlKey) {\n            return;\n        }\n        this.handleKeypressImpl(keyCode);\n    }\n    handleKeypressImpl(keyCode) {\n        switch (keyCode) {\n            case undefined:\n            case 9:\n            case 13:\n                return;\n            case 43:\n                this.inputService.changeToPositive();\n                break;\n            case 45:\n                this.inputService.changeToNegative();\n                break;\n            default:\n                if (this.inputService.canInputMoreNumbers) {\n                    let selectionRangeLength = Math.abs(this.inputService.inputSelection.selectionEnd - this.inputService.inputSelection.selectionStart);\n                    if (selectionRangeLength == this.inputService.rawValue.length) {\n                        this.setValue(null);\n                    }\n                    this.inputService.addNumber(keyCode);\n                }\n                break;\n        }\n        this.onModelChange(this.inputService.value);\n    }\n    handlePaste(event) {\n        setTimeout(() => {\n            this.inputService.updateFieldValue();\n            this.setValue(this.inputService.value);\n            this.onModelChange(this.inputService.value);\n        }, 1);\n    }\n    updateOptions(options) {\n        this.inputService.updateOptions(options);\n    }\n    getOnModelChange() {\n        return this.onModelChange;\n    }\n    setOnModelChange(callbackFunction) {\n        this.onModelChange = callbackFunction;\n    }\n    getOnModelTouched() {\n        return this.onModelTouched;\n    }\n    setOnModelTouched(callbackFunction) {\n        this.onModelTouched = callbackFunction;\n    }\n    setValue(value) {\n        this.inputService.value = value;\n    }\n    /**\n     * Passthrough to setTimeout that can be stubbed out in tests.\n     */\n    timer(callback, delayMillis) {\n        setTimeout(callback, delayMillis);\n    }\n}\n\nconst CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => CurrencyMaskDirective),\n    multi: true,\n};\nclass CurrencyMaskDirective {\n    constructor(currencyMaskConfig, elementRef, keyValueDiffers) {\n        this.currencyMaskConfig = currencyMaskConfig;\n        this.elementRef = elementRef;\n        this.keyValueDiffers = keyValueDiffers;\n        this.options = {};\n        this.optionsTemplate = {\n            align: \"right\",\n            allowNegative: true,\n            allowZero: true,\n            decimal: \".\",\n            precision: 2,\n            prefix: \"$ \",\n            suffix: \"\",\n            thousands: \",\",\n            nullable: false,\n            inputMode: CurrencyMaskInputMode.FINANCIAL\n        };\n        if (currencyMaskConfig) {\n            this.optionsTemplate = currencyMaskConfig;\n        }\n        this.keyValueDiffer = keyValueDiffers.find({}).create();\n    }\n    ngAfterViewInit() {\n        this.elementRef.nativeElement.style.textAlign = this.options && this.options.align ? this.options.align : this.optionsTemplate.align;\n    }\n    ngDoCheck() {\n        if (this.keyValueDiffer.diff(this.options)) {\n            this.elementRef.nativeElement.style.textAlign = this.options.align ? this.options.align : this.optionsTemplate.align;\n            this.inputHandler.updateOptions(Object.assign({}, this.optionsTemplate, this.options));\n        }\n    }\n    ngOnInit() {\n        this.inputHandler = new InputHandler(this.elementRef.nativeElement, Object.assign({}, this.optionsTemplate, this.options));\n    }\n    handleBlur(event) {\n        this.inputHandler.getOnModelTouched().apply(event);\n    }\n    handleCut(event) {\n        if (!this.isChromeAndroid()) {\n            !this.isReadOnly() && this.inputHandler.handleCut(event);\n        }\n    }\n    handleInput(event) {\n        if (this.isChromeAndroid()) {\n            !this.isReadOnly() && this.inputHandler.handleInput(event);\n        }\n    }\n    handleKeydown(event) {\n        if (!this.isChromeAndroid()) {\n            !this.isReadOnly() && this.inputHandler.handleKeydown(event);\n        }\n    }\n    handleKeypress(event) {\n        if (!this.isChromeAndroid()) {\n            !this.isReadOnly() && this.inputHandler.handleKeypress(event);\n        }\n    }\n    handlePaste(event) {\n        if (!this.isChromeAndroid()) {\n            !this.isReadOnly() && this.inputHandler.handlePaste(event);\n        }\n    }\n    handleDrop(event) {\n        if (!this.isChromeAndroid()) {\n            event.preventDefault();\n        }\n    }\n    isChromeAndroid() {\n        return /chrome/i.test(navigator.userAgent) && /android/i.test(navigator.userAgent);\n    }\n    isReadOnly() {\n        return this.elementRef.nativeElement.hasAttribute('readonly');\n    }\n    registerOnChange(callbackFunction) {\n        this.inputHandler.setOnModelChange(callbackFunction);\n    }\n    registerOnTouched(callbackFunction) {\n        this.inputHandler.setOnModelTouched(callbackFunction);\n    }\n    setDisabledState(value) {\n        this.elementRef.nativeElement.disabled = value;\n    }\n    writeValue(value) {\n        this.inputHandler.setValue(value);\n    }\n}\nCurrencyMaskDirective.Éµfac = function CurrencyMaskDirective_Factory(t) { return new (t || CurrencyMaskDirective)(Éµngcc0.ÉµÉµdirectiveInject(CURRENCY_MASK_CONFIG, 8), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.KeyValueDiffers)); };\nCurrencyMaskDirective.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: CurrencyMaskDirective, selectors: [[\"\", \"currencyMask\", \"\"]], hostBindings: function CurrencyMaskDirective_HostBindings(rf, ctx) { if (rf & 1) {\n        Éµngcc0.ÉµÉµlistener(\"blur\", function CurrencyMaskDirective_blur_HostBindingHandler($event) { return ctx.handleBlur($event); })(\"cut\", function CurrencyMaskDirective_cut_HostBindingHandler($event) { return ctx.handleCut($event); })(\"input\", function CurrencyMaskDirective_input_HostBindingHandler($event) { return ctx.handleInput($event); })(\"keydown\", function CurrencyMaskDirective_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); })(\"keypress\", function CurrencyMaskDirective_keypress_HostBindingHandler($event) { return ctx.handleKeypress($event); })(\"paste\", function CurrencyMaskDirective_paste_HostBindingHandler($event) { return ctx.handlePaste($event); })(\"drop\", function CurrencyMaskDirective_drop_HostBindingHandler($event) { return ctx.handleDrop($event); });\n    } }, inputs: { options: \"options\" }, features: [Éµngcc0.ÉµÉµProvidersFeature([CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR])] });\nCurrencyMaskDirective.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CURRENCY_MASK_CONFIG,] }] },\n    { type: ElementRef },\n    { type: KeyValueDiffers }\n];\nCurrencyMaskDirective.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CURRENCY_MASK_CONFIG,] }] },\n    { type: ElementRef },\n    { type: KeyValueDiffers }\n];\nCurrencyMaskDirective.propDecorators = {\n    options: [{ type: Input }],\n    handleBlur: [{ type: HostListener, args: [\"blur\", [\"$event\"],] }],\n    handleCut: [{ type: HostListener, args: [\"cut\", [\"$event\"],] }],\n    handleInput: [{ type: HostListener, args: [\"input\", [\"$event\"],] }],\n    handleKeydown: [{ type: HostListener, args: [\"keydown\", [\"$event\"],] }],\n    handleKeypress: [{ type: HostListener, args: [\"keypress\", [\"$event\"],] }],\n    handlePaste: [{ type: HostListener, args: [\"paste\", [\"$event\"],] }],\n    handleDrop: [{ type: HostListener, args: [\"drop\", [\"$event\"],] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(CurrencyMaskDirective, [{\n        type: Directive,\n        args: [{\n                selector: \"[currencyMask]\",\n                providers: [CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR]\n            }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [CURRENCY_MASK_CONFIG]\n            }] }, { type: Éµngcc0.ElementRef }, { type: Éµngcc0.KeyValueDiffers }]; }, { options: [{\n            type: Input\n        }], handleBlur: [{\n            type: HostListener,\n            args: [\"blur\", [\"$event\"]]\n        }], handleCut: [{\n            type: HostListener,\n            args: [\"cut\", [\"$event\"]]\n        }], handleInput: [{\n            type: HostListener,\n            args: [\"input\", [\"$event\"]]\n        }], handleKeydown: [{\n            type: HostListener,\n            args: [\"keydown\", [\"$event\"]]\n        }], handleKeypress: [{\n            type: HostListener,\n            args: [\"keypress\", [\"$event\"]]\n        }], handlePaste: [{\n            type: HostListener,\n            args: [\"paste\", [\"$event\"]]\n        }], handleDrop: [{\n            type: HostListener,\n            args: [\"drop\", [\"$event\"]]\n        }] }); })();\n\nclass NgxCurrencyModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxCurrencyModule,\n            providers: [{\n                    provide: CURRENCY_MASK_CONFIG,\n                    useValue: config,\n                }]\n        };\n    }\n}\nNgxCurrencyModule.Éµfac = function NgxCurrencyModule_Factory(t) { return new (t || NgxCurrencyModule)(); };\nNgxCurrencyModule.Éµmod = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineNgModule({ type: NgxCurrencyModule });\nNgxCurrencyModule.Éµinj = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineInjector({ imports: [[CommonModule, FormsModule]] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(NgxCurrencyModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule, FormsModule],\n                declarations: [CurrencyMaskDirective],\n                exports: [CurrencyMaskDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(NgxCurrencyModule, { declarations: function () { return [CurrencyMaskDirective]; }, imports: function () { return [CommonModule, FormsModule]; }, exports: function () { return [CurrencyMaskDirective]; } }); })();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR, CurrencyMaskDirective, CurrencyMaskInputMode, NgxCurrencyModule, CURRENCY_MASK_CONFIG as Éµa };\n\n//# sourceMappingURL=ngx-currency.js.map"],"sourceRoot":"webpack:///"}